
1. Introduction to DSA

1.1 What are Data Structures and Algorithms?

Data Structures: A data structure is a particular way of organizing, managing, and storing data so that it can be used efficiently. The choice of data structure impacts the performance of algorithms.
    Examples: Arrays, Linked Lists, Stacks, Queues, Trees, Graphs, Hash Tables, etc.

Algorithms: An algorithm is a finite sequence of well-defined instructions to solve a specific problem. It is a step-by-step procedure that takes an input and produces the desired output.
    Examples: Sorting algorithms (like Merge Sort, Quick Sort), Searching algorithms (like Binary Search), Graph algorithms (like Dijkstra's), etc.


1.2 Types of Data Structures

Data structures can be categorized based on their nature and how they organize and manage data:

Primitive Data Structures: Directly operated by machine instructions.
    Examples: Integer, Float, Character, Boolean.

Non-Primitive Data : These are more complex structures that are derived from primitive types.
    Linear Data : Data elements are stored in a sequential manner.
        : Arrays, Linked Lists, Stacks, Queues.
    Non-Linear Data : Data elements are stored in hierarchical or networked structures.
        : Trees, Graphs.

Static Data : Size and memory allocation are fixed at compile time.
    : Arrays.

Dynamic Data : Size and memory allocation can change at runtime.
    : Linked Lists.

Abstract Data Types (ADT): ADTs focus on what operations can be performed, rather than how they are implemented.
    : Stack (with push and pop operations), Queue (with enqueue and dequeue operations).

 1.3 Types of Algorithms

Algorithms can be classified based on their approach and the kind of problems they solve:

Search : Used to retrieve information from data structures.
    : Linear Search, Binary Search.

Sorting : Used to arrange data in a specific order.
    : Bubble Sort, Merge Sort, Quick Sort.

Divide and Conquer : These algorithms divide the problem into smaller sub-problems, solve them independently, and then combine the results.
    : Merge Sort, Quick Sort, Binary Search.

Greedy : These algorithms make the best choice at each step, hoping to find the global optimum.
    : Huffman Coding, Kruskal’s Algorithm, Prim’s Algorithm.

Dynamic Programming : These algorithms solve sub-problems and store their results to avoid redundant calculations.
    : Fibonacci Series, Knapsack Problem, Longest Common Subsequence.

Backtracking : These algorithms try to build a solution incrementally and remove solutions that fail to meet the problem’s constraints.
    : N-Queens Problem, Sudoku Solver.

Graph : These are used to process graph structures, such as finding the shortest path, detecting cycles, etc.
    : Dijkstra’s Algorithm, Bellman-Ford Algorithm, Depth First Search (DFS), Breadth First Search (BFS).

String : These algorithms deal with string manipulation problems, such as searching or comparing patterns within a string.
    : Knuth-Morris-Pratt (KMP), Rabin-Karp, Boyer-Moore.

Mathematical : These are used for mathematical computations such as prime number generation, GCD calculation, etc.
    : Euclidean Algorithm for GCD, Sieve of Eratosthenes for Prime Numbers.
